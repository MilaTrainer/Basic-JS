'use strict';
//методы над массивами
// существую встроеныые, по умолчанию 

// метод, перебераемый массив (вместо циула for) 
// вызывет функцию для кажого элемента массива
// не отдает результат, ,без ретерн
// создаем массив 
const names = ['anna', 'oleg', 'tom', 'maxim'];
const newNames = [];
//метод forEach - для каждого (более короткий и красивый, чем у цикла)
// бкдем совершать для кажого элемента этого массива
// так как метод- это функция , поэтому нам нужны names.forEach()  круглые скобки
// в круглах  скабках (тут будет функция, которая является параметром метода), эта функция вызывается для каждого элемента массива
// фунуиця ананимная, callback - это людая функция, которая вызывается внутри forEach, функция обратного вызова
// 
names.forEach(function(//полный синтаксис callback функции,
    //тут ее параметры 
    element,index
){
// у функции callback есть свое тело 
console.log(element); //выведи в консоль
newNames.push(element + ' молодец'); //тут занесли элемнты в новый масив из старого + приклеилось еще слова

});
console.log(newNames); //получится из 21 строски массив из 3х элементов 
// смысл в том, что для каждого элемента массива 'names' на котором вызван forEach - будет выполняться тело вот этой фукнции (callback)
// принимает от 1 до 3 параметров item/ element/ index
// не изменяем сами item/ element/ index -мы с ними что-то делаем 
// например выводить в консоль, добавлять в другой массив,

// стрелочный синтаксис
names.forEach(element => newNames.push(element+ '!'));

    // есть ли один элемент, то передается без кругдах скобок names.forEach(element ()=>  и если решение/лоника написаны только в одну строчку ,то бе {}

console.log(newNames);



